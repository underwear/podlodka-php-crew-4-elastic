> **Важно!** Все задания нужно выполнять используя контейнеры, которые мы вам заранее подготовили.
> Вот [тут](./HOW-TO-LAUNCH.md) вы найдете инструкцию по их запуску.

## Задания

### Задание 1 - Знакомство с Kibana

Откройте **Kibana** по адресу http://localhost:5601

Используя **Dev Tools** создайте индекс `articles`:

```
PUT /articles
```

Затем добавьте в индекс новый документы, выполнив команды:

```
POST /articles/_doc
{
  "title": "What I love",
  "body": "I love php and podlodka"
}

POST /articles/_doc
{
  "title": "What I also love",
  "body": "I love beer"
}

POST /articles/_doc
{
  "title": "What I hate",
  "body": "I hate javascript"
}
```

Затем произведите поиск по вставленным документам и найдите вхождение слов `beer love` в поле `body`:

```
GET articles/_search
{
  "query": {
    "match": {
      "body": {
        "query": "beer love"
      }
    }
  }
}
```

### Задание 2 - PHP + Elasticsearch

В данном задании мы будем работать с заранее подготовленным дата-сэтом, который лежит по
пути `./dev-test-data/harvard_reviews.csv`

С помощью php мы зальем данные из этого дата-сэта в elasticsearch, и потом потренируемся отправлять запросы прямо из
кода.

Свой код вы можете писать в файле `index.php`. В нем уже есть подключенный и настроенный клиент для работы с
elasticsearch, который вам понадобится для отправки запросов. Также доступны функции отладки `dump()` и `dd()`.

Для того чтобы запустить `index.php` с помощью контейнера `app` выполните команду ниже:

```shell
docker compose exec -it app php index.php
```

Если вы увидели на экране сообщение `Hello from index.php!` – значит у вас все получилось.

#### Шаг 1 - Создаем индекс

Откройте файл `index.php`.

Затем удалите строчку кода:

```php
dd('Hello from index.php!');
```

Теперь вставьте в конце файла

```
$response = $client->indices()->create([
    'index' => 'harvard_reviews'
]);

dump($response->getReasonPhrase());
```

И запустите скрипт для создания индекса.

Если после запуска скрипта вы увидите сообщение "OK", значит у вас все получилось и индекс был успешно создан

#### Шаг 2 - заливаем данные

> Удалите код по созданию индекса, который остался с прошлого шага.

Теперь нам нужно пропарсить файл `./dev-test-data/harvard_reviews.csv` и отправить данные в Elasticsearch.

Писать код логики парсинга **не нужно**, просто воспользуйтесь классом `DataProvider`.

На каждой итерации в переменную `$item` будет подставляться данные (ассоциативным массив)

```php
$dataProvider = new \App\DataProvider('./dev-test-data/harvard_reviews.csv');

// Итерируем через каждую строку CSV-файла.
// Каждая строка представлена в виде ассоциативного массива.
// Ключи массива соответствуют заголовкам столбцов в CSV-файле.
foreach ($dataProvider->getIterator() as $item) {
    dump($item);
}
```

Отредактируйте код внутри `foreach` так, чтобы он на каждой итерации отправлял документ в Elasticsearch.

Пример отправки документа в Elasticsearch:

```php
$params = [
    'index' => 'my_index',
    'body'  => [
        'someField' => 'abc',
        'anotherField' => 12345
    ]
];

$response = $client->index($params);
echo "\n" . "Document has been sent to Elasticsearch";
```

Затем с помощью DevTool в Kibana выполните запрос статистики и посмотрите, сколько документов было добавлено:

```
GET my_index/_stats 
```

Затем выполните пустой поисковой запрос:

```
GET my_index/_search
```

И ознакомьтесь с набором полей документов

#### Шаг 3 - Ищем

> Удалите код с прошлого шага

Теперь потренируемся отправлять поисковые запросы. Мы будем использовать **fuzzy** (перев. с англ. "неточный") поиск.

Давайте поищем документы, которые в поле `text` содержат `Garvard` (очевидно что должно было быть Harvard)

Скопируйте и поправьте код ниже, чтобы он заработал

```php
$params = [
    'index' => '{your-index-name}',
    'body' => [
        'query' => [
            'fuzzy' => [
                '{your-field-name}' => [
                    'value' => '{your-search-term}',
                    'fuzziness' => 'AUTO'
                ]
            ]
        ]
    ]
];

$results = $client->search($params);

dd($results->asArray());
```

#### Шаг 4 - фильтруем

Как мы выяснили, при создании индекса не обязательно объявлять маппинг.
Однако для некоторых операций он все-таки необходим.
Давайте обновим ранее созданый нами индекс, и укажем маппинг для двух полей, 'rating' и 'helpful_votes'

```
$params = [
    'index' => 'harvard_reviews',
    'body' => [
        'properties' => [
            'helpful_votes' => [
                'type' => 'integer'  // Устанавливаем тип данных как целочисленный
            ],
            'rating' => [
                'type' => 'integer'  // Также устанавливаем для поля rating тип integer
            ]
        ]
    ]
];
$response = $client->indices()->putMapping($params);
print_r($response);
```

И теперь финальное задание:

Напишите код, который выведет 5 самых полезных отзывов с оценкой "4" и выше. 

Самые полезные отзывы можно выявить по количеству "голосов" за данный отзыв. Их количество находится в свойстве `helpful_votes`

Вот пример запроса с фильтрацией:

```php
$params = [
    'index' => 'harvard_reviews',
    'size' => 20,  // Выводим 20 результатов
    'body'  => [
        'query' => [
            'range' => [
                'published_date' => [
                    'gte' => '2015-01-01T00:00:00',  // ищем ">=" начало 2015 года
                    'lte' => '2016-12-31T23:59:59'   // ищем "<=" конец 2016 года
                ]
            ]
        ],
        'sort' => [
            'published_date' => [
                'order' => 'asc'  // Сортировка по возрастанию даты
            ]
        ]
    ]
];

$results = $client->search($params);

dd($results->asArray());

```

Адаптируйте этот пример под свою задачу